== How to Tag Normative Rules in the ISA Manuals

The ISA manuals contain a mix of normative and informative (AKA non-normative) content.
We use AsciiDoctor's anchor facility to tag normative text which is extracted by tools
provided in the link:https://github.com/riscv/docs-resources[docs-resources GitHub repository]
to create machine-readable and human-readable representations of normative rules.

=== Normative Rules Overview

First, read the link:https://github.com/riscv/docs-resources/blob/main/normative-rules.md[How to Tag Normative Rules in RISC-V International Standards] for information that applies to all RISC-V International standards. This document provides information such as:

* What exactly is a "normative rule"?
* How does one add normative rule tags to the AsciiDoc files using the AsciiDoc anchor facility?
* Ins and outs and gotchas when using the AsciiDoc anchor facility.
* How are the normative rules extracted from the AsciiDoc files?

Normative rules should have unique, short names that are easy to put in testplans. They reference tags in the AsciiDoc source files. The tag name matches the rule name in simple 1-1 cases (except the tag contains norm: and the rule does not). The normative rules are defined on a per-document basis with a YAML file listing the rules, their tags, and a short summary. The Makefile in riscv-isa-manual generates a JSON file in the build directory containing all of the normative rules for the document with their tags.

=== Naming Normative Rules

Names should be short, descriptive, and as consistent as possible.  Rules related to an instruction, CSR, or CSR field should start with the instruction, CSR, or field name.  Dots in the instruction or CSR field are replaced with dashes to keep tools happy.

.Normative Rule Naming Convention
[options="header"]
|===
|Scenario|Format|Example
|Simple instruction|<instr>_op, <inst>_enc|add_op, c-add_op, add_enc
|Additional instruction rules|<instr>_<short-descriptor>|sll_op, sll_shamt_rv32, sll_shamt_rv64
|CSR|<csr_name>_sz, <csr_name>_acc, <csr_name>_mode, <csr_name>_op|mscratch_sz, mscratch_acc, mscratch_mode
|CSR bitfield|<csr_name>-<field_name>_sz, <csr_name>-<field_name>_acc, <csr_name>-<field_name>_op|mstatus-mpp_sz, mstatus-mpp_acc, mstatus-mpp_op
|Parameters|<param>_param|pmp_granularity_param
|Categories|<category>_<short_description>|br_targ, ldst_ea, R-type_operands
|Extension|<ext>_<short-description>|Sv_bare, Sv48_gigapage, Sv57_terapage, pmp_addr_match
|===

There should be at least two normative rules (op & enc) per instruction, even if there is a single tag describing multiple instructions. _op defines the instruction operation. _enc defines instruction type and op/func fields.

Each CSR typically has at least the following rules, with text from the spec defining the size, access type, privilege mode, and operation.

* sz (size in bits)
* acc (read/write access type; relates to rw, ro, ro-h, rw-r, rw-rh from UDB)
* mode (associated privilege mode)
* op (operation, optional for CSRs such as mscratch that do not affect system behavior)

Each CSR with bitfields should have at least the following rules for each field:

* sz (size in bits)
* acc (some fields like mstatus.SD may be read-only even if the overall CSR is read/write)
* op

Reserved instructions, CSR fields, etc. use _rsv suffix.

Each parameter name should exactly match the name in https://github.com/riscv-software-src/riscv-unified-db/tree/main/spec/std/isa/ext[UDB], except that the name is lower case instead of all caps, and is followed by a _param suffix.

=== Tagging Normative Rules in ISA Manuals

The ISA manual builds upon the anchor naming convention of a "norm:" prefix by following it with a name.  If there is a 1:1 relationship between the rule and the tag (the common case), then the name is simply the rule name.  If there is a many:1 or 1:many relationship, then see examples below.

=== Normative Rule Definitions

Every normative rule is associated with one ratified specification document, such as a chapter of an ISA manual or a profile.  The normative rule may relate to more than one document but it must always have one primary document.  The normative rule is defined in a YAML file associated with the primary document.

Each specification AsciiDoc file has a corresponding YAML file defining the normative rules primarily associated with that specification.  For example, the https://github.com/riscv/riscv-isa-manual/blob/main/src/rv64.adoc[rv64.adoc] chapter of the Unprivileged ISA Manual has a corresponding rv64.yaml file in normative_rules.

The YAML file lists all of the normative rules contained in that document.  Each rule must have a rule name and a list of one or more tags.  It should have a short summary.  https://github.com/riscv-software-src/riscv-unified-db[UDB] contains additional metadata and a pointer to the normative rule name, so the rule does not attempt to duplicate complex metadata already captured in UDB.  The form of the YAML is:

.rv64.yaml
[source,yaml]
----
$schema: "normative_rules_schema.json#"

normative_rule_definitions:
  # 1-to-1 rule to tag
  - name: rv64_x_sz
    summary: XLEN=64
    tags: ["norm:rv64_x_sz"]
  # many-to-1 rules to tag
  - names: [sll_shamt_rv64, srl_shamt_rv64, sra_shamt_rv64]
    tags: norm:shamt_rv64
  # 1-to-many rule to tags where multiple tags are needed to create a complete self-contained rule
  - name: lh_rv64i_op
    summary: lh 64-bit sign extension
    tags:["norm:lw_rv64i_op", "norm:subword_rv64i_load"]
  # another 1-to-many rule to tags where multiple tags are needed to create a complete self-contained rule
  - name: lhu_rv64i_op
    summary: lhu 64-bit zero extension
    tags:["norm:lw_rv64i_op", "norm:lwu_rv64i_op", "norm:subword_rv64i_load"]
----

These rules reference the following tags in the AsciiDoc:

.rv64.adoc
[source,adoc]
----
[[norm:rv64_x_sz]]
RV64I widens the integer registers and supported user address space to
64 bits (XLEN=64 in <<gprs>>).

SLL, SRL, and SRA perform logical left, logical right, and arithmetic
right shifts on the value in register _rs1_ by the shift amount held in
register _rs2_. [#norm:shamt_rv64]#In RV64I, only the low 6 bits of _rs2_ are considered
for the shift amount.#

[#norm:lw_rv64i_op]#The LW instruction loads a 32-bit value from memory and sign-extends
this to 64 bits before storing it in register _rd_ for RV64I.#
[#norm:lwu_rv64i_op]#The LWU instruction, on the other hand, zero-extends the 32-bit value from
memory for RV64I.# [#norm:subword_rv64i_load]#LH and LHU are defined analogously for 16-bit values, as are LB and LBU for 8-bit values.#
----
